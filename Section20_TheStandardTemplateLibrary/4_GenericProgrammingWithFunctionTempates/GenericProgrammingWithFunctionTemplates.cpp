/***
 * [Generic programming with function templates]
 * 
 * What is a C++ Template?
 *  Blueprint   => That the compiler uses to generate specialized functions in classes. 
 *  Function and class templates        => The idea with templates is that we define a template with a placeholder type, and then we plug in the actual type we want when we need it. 
 *  Allow plugging-in any data type
 *  Compiler generates the appropriate function/class from the blueprint    => Then the compiler generates the specific function or class that we need. Remember all of this happens at compile time. If you're coming from other programming languages, you might be used to this happening at runtime, C++ does it at compile time. So we get the benefit of the compiler performing type checking for us before the program executes. 
 *  Generic programming / meta-programming      => C++ template supports the concept of generic programming or meta=programming since we're providing a generic representation of a function of class and then the compiler writes the actual function or class for us. With power comes complexity. C++ templates can be very complex. And while the concept is easy to understand, seeing them in practice can sometimes be very intimidating, even for experienced programmers. Also, the error message is provided by the compiler can be very difficult to understand. 
 * 
 * Let's revisit the max function from the last lecture
 * 
 *  int max (int a, int b){
 *      return (a > b) ? a : B;
 *  }
 * 
 * int x = 100;
 * int y = 200;
 * std::cout << max(x,y);       // displays 200
 * 
 * [max function]
 *  Now suppose we need to determine the max of 2 doubles, and 2 chars
 * 
 *  int max(int a, int b){
 *      return (a > b) ? a : b;
 *  }
 * 
 *  int max(double a, double b){
 *      return (a > b) ? a : b;
 *  }
 * 
 *  int max(char a, char b){
 *      return (a > b) ? a : b;
 *  }
 * 
 * [max function as a template function]
 *      We can replace type we want to generalize with a name, Say T
 *      But now this won't compile
 * 
 *  T max (T a, T b){       => The computer won't know what to do with this, and it's going to give us a compiler error. We need to explicitly tell the compiler that this is a template function.
 *      return (a > b) ? a : b;
 *  }
 * 
 * 
 *  We need to tell the compiler this is a template function
 *  We also need to tell it that T is the template parameter
 * 
 *  template <typename T>   => This will not generate any code. It's simply a template or a blueprint. Code is not generated by the compiler until the user uses a specialized version of the template. 
 *  T max (T a, T b){
 *      return (a > b) ? a : b;
 *  }
 * 
 *  We may also use class instead of typename
 * 
 *  template <class T>
 *  T max (T a, T b){
 *      return (a > b) ? a : b;
 *  }   
 * 
 *  Now the compiler can generate the appropriate function from the template
 *  Note, this happens at compile-time!
 * 
 *  int a {10};
 *  int b {20};
 *  std::cout << max<int>(a, b);
 * 
 *  Many times the compiler can deduce the type and template parameter is not needed
 *  Depending on the type of a and b, the compiler will figure it out.
 * 
 *  std::cout << max<double> (c, d);    => The compiler now knows that it needs to generate the double version of the max function off in the compiler can deduce the type of the template parameter, and we don't even need to provide it as in the second statement.
 *  std::cout << max(c, d);
 * 
 *  And we can use almost any type we need
 *  char a {'A'};
 *  char b {'Z'};
 *  std::cout << max(a, b) << std::endl;
 * 
 *  Notice the type MUST support the > operator either natively or as an overloaded operator (operator>)
 * 
 *  template <typename T>       => Notice that the code in the template function is using the greater than operator to compare a and b. This means that whatever type we use for T, must support this operator. 
 *  T max (T a, T b){           => But for own class types, we have to be sure that our class overloads the greater than operator or this won't compile.
 *      return (a > b) ? a : b;
 *  }
 *      
 *  The following will not compile unless Player overloads operator >
 * 
 *  Player p1 {"Hero", 100, 20};
 *  Player p2 {"Enemy", 99, 3};
 * 
 *  std::cout << max<Player>(p1, p2);   => The compiler will generate the max function that expects and compares. Unless the player class overloads to greater than operator, this code won't compile. 
 * 
 * [Multiple types as template parameters]
 *  We can have multiple template parameters
 *  And their types can be different
 * 
 *  template <typename T1, typename T2> => There is no limit to the number of template parameters you can have. And of course, they can bve of different types. 
 *  void func(T1 a, T2 b){              => Notice that we specified to template parameters in this case. So there's the function declaration. 
 *      std::cout << a << " " << b;
 *  }  
 * 
 *  When we use the function we provide the template parameters
 *  Often the compiler can deduce them.
 * 
 *  func<int, double> (10, 20.2);   => We can call func and explicit would provide an integer in the double in this example. Or in this case of the cost of func with no template parameters, the compiler will deduce the types from the function arguments. 
 *  func('A', 12.4);                => Now can pass by value by reference, by pointer with const modifiers and so forth. And all of the function parameters don;t have to be generic. Can see all the possibilities and combinations. 
 * ***/

#include <iostream>
#include <string>

template <typename T>
T min (T a, T b){
    return (a < b) ? a : b;
}

template <typename T1, typename T2>
void func(T1 a, T2 b){
    std::cout << a << " " << b << std::endl;
}

struct Person{
    std::string name;
    int age;
    bool operator<(const Person &rhs) const {
        return this->age < rhs.age;
    }
};

std::ostream &operator<<(std::ostream &os, const Person &p){
    os<<p.name;
    return os;
}

template <typename T>
void my_swap(T &a, T &b){
    T temp = a;
    a = b;
    b = temp;
}

int main(){
    // The compiler smart enough to deduce that these are integers. So it's going to create the integer version of it. A lot of times the compiler. We'll figure it out. Other times the compiler won't figure it out depending on how complex the template function is. 
    std::cout << min<int>(2,3) << std::endl;
    std::cout << min(2,3) << std::endl;
    std::cout << min('A', 'B') << std::endl;
    std::cout << min(12.5,9.2) << std::endl;
    std::cout << min(5+2*2,8+40) << std::endl;

    Person p1 {"Curly", 50};
    Person p2 {"Moe", 30};
    Person p3 = min(p1, p2);    // Error:  error: no match for 'operator ' (operand types are 'Person' and 'Person'). Because it doesn't know how to compare 2 persons using that less than. => Must write a real simple overloaded operator.
    std::cout << p3.name << " is younger" << std::endl;

    func<int, int>(10, 20);
    func(10,20);
    func<char, double>('A', 12.4);
    func(1000,"Testing");
    func(2000, std::string{"Frank"});

    func(p1, p2);   // error:. Because there is no overloaded insertion operator for a person. So that don't work. 

    int x{100};
    int y {200};
    my_swap(x,y);
    func(x, y);

    return 0;
}